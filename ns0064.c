/*                                                                           */
/* NAME                                                                      */
/*   ns0064.c - check paired FASTQ and eliminate filtered reads              */
/*                                                                           */
/* SYNOPSIS                                                                  */
/*   ns0064 -a  input_R1_fastq -b  input_R2_fastq \                          */
/*          -c output_R1_fastq -d output_R2_fastq [-h] [-j] [-x]             */
/*                                                                           */
/* USAGE                                                                     */
/*   $ gcc -W -Wall -s -O -ansi -pedantic -Werror -o ns0064 ns0064.c         */
/*   $ ns0064 -h                                                             */
/*   $ ns0064 -a sample_R1_0.fastq -b sample_R2_0.fastq \                    */
/*            -c sample_R1_1.fastq -d sample_R2_1.fastq                      */
/*                                                                           */
/* DESCRIPTION                                                               */
/*   This programme reads a pair of R1 and R2 FASTQ files                    */
/*   and performs FASTQ format check.                                        */
/*   The input FASTQ files are assumed to be generated by Illumina CASAVA.   */
/*   In addition, all the reads are assumed to have the same lengths,        */
/*   expecting that they are unprocessed FASTQ data.                         */
/*   Read entries that have passed CASAVA filter are printed onto            */
/*   R1 and R2 output FASTQ files, respectively.                             */
/*   Using option -x, it does not check read lengths.                        */
/*   Non-Illumina FASTQ files can also be processed with option -j.          */
/*                                                                           */
/* OPTIONS                                                                   */
/*   -a  input R1 file name                                                  */
/*   -b  input R2 file name                                                  */
/*   -c  output R1 file name                                                 */
/*   -d  output R2 file name                                                 */
/*   -h  print simple usage                                                  */
/*   -j  process non-Illumina FASTQ                                          */
/*   -x  avoid length check                                                  */
/*                                                                           */
/* AUTHOR                                                                    */
/*   Coded by Kohji OKAMURA, Ph.D.                                           */
/*                                                                           */
/* HISTORY                                                                   */
/*   2015-12-26  Launched                                                    */
/*   2016-01-06  Released                                                    */
/*                                                                           */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define FLAGS 8
#define LINES 8
#define FILES 4
#define MAX_CHAR 8192
#define MAX_CHID  512

extern char *optarg;
int getopt(int, char * const [], const char *);
int flag[FLAGS];
char file_name[FILES][MAX_CHID];
char line[LINES][MAX_CHAR];


int main(int argc, char *argv[])
{
  int i, opt, length = -1;
  FILE *fastqa, *fastqb, *fastqc, *fastqd;
  char id1[MAX_CHID], id2[MAX_CHID];
  char filt[4][MAX_CHAR];

  for (i = 0; i < FLAGS; i++) flag[i] = 0;
  while ((opt = getopt(argc, argv, "a:b:c:d:hjx")) != -1)
  {
    switch (opt)
    {
      case 'a': strcpy(file_name[0], optarg); flag[0] = 1;
                break;
      case 'b': strcpy(file_name[1], optarg); flag[1] = 1;
                break;
      case 'c': strcpy(file_name[2], optarg); flag[2] = 1;
                break;
      case 'd': strcpy(file_name[3], optarg); flag[3] = 1;
                break;
      case 'h': fprintf(stderr, "Usage: %s [-h] [-j] [-x] "
                  "-a sample_R1_0.fastq -b sample_R2_0.fastq "
                  "-c sample_R1_1.fastq -d sample_R2_0.fastq\n", argv[0]);
                return -1;
      case 'j': flag[4] = 1;
                break;
      case 'x': flag[5] = 1;
                break;
      default:  fprintf(stderr, "Warning, unknown option: %c\n", opt);
                /* does not exit */
    }
  }
  if (flag[0] * flag[1] * flag[2] * flag[3] != 1)
  {
    fprintf(stderr, "Error: options -a, -b, -c, and -d are requied\n");
    exit(-3);
  }
  if ((fastqa = fopen(file_name[0], "r")) == NULL)
  { fprintf(stderr, "File open error: %s\n", file_name[0]); exit(-4); }
  if ((fastqb = fopen(file_name[1], "r")) == NULL)
  { fprintf(stderr, "File open error: %s\n", file_name[1]); exit(-5); }
  if ((fastqc = fopen(file_name[2], "w")) == NULL)
  { fprintf(stderr, "File open error: %s\n", file_name[2]); exit(-6); }
  if ((fastqd = fopen(file_name[3], "w")) == NULL)
  { fprintf(stderr, "File open error: %s\n", file_name[3]); exit(-7); }

  while (fgets(line[0], MAX_CHAR, fastqa) != NULL)
  {
    if (fgets(line[1], MAX_CHAR, fastqa) == NULL)
    { fprintf(stderr, "FASTQ format error 1: %s", line[1]); exit(-9); }
    if (fgets(line[2], MAX_CHAR, fastqa) == NULL)
    { fprintf(stderr, "FASTQ format error 2: %s", line[2]); exit(-10); }
    if (fgets(line[3], MAX_CHAR, fastqa) == NULL)
    { fprintf(stderr, "FASTQ format error 3: %s", line[3]); exit(-11); }

    if (fgets(line[4], MAX_CHAR, fastqb) == NULL)
    { fprintf(stderr, "FASTQ format error 4: %s", line[4]); exit(-12); }
    if (fgets(line[5], MAX_CHAR, fastqb) == NULL)
    { fprintf(stderr, "FASTQ format error 5: %s", line[5]); exit(-13); }
    if (fgets(line[6], MAX_CHAR, fastqb) == NULL)
    { fprintf(stderr, "FASTQ format error 6: %s", line[6]); exit(-14); }
    if (fgets(line[7], MAX_CHAR, fastqb) == NULL)
    { fprintf(stderr, "FASTQ format error 7: %s", line[7]); exit(-15); }

    sscanf(line[0], "%s", id1);
    sscanf(line[4], "%s", id2);
    if (strcmp(id1, id2) != 0)
    { fprintf(stderr, "Format error 8: %s%s", line[0], line[4]); exit(-16); }
    if (length < 0) { length = (int)strlen(line[1]); }

    if (flag[4] == 0)	/* Illumina FASTQ */
    {
      if (sscanf(line[0], "%*[^ ] %[^:]:%[^:]:", filt[0], filt[1]) != 2)
      { fprintf(stderr, "Format error 9: %s (%s)", line[0], id1); exit(-17); }
      if (filt[1][0] == 'Y') { continue; }	/* do not output filtered */
      if (sscanf(line[4], "%*[^ ] %[^:]:%[^:]:", filt[2], filt[3]) != 2)
      { fprintf(stderr, "Format error 10: %s (%s)", line[0], id2); exit(-18); }
      if (filt[3][0] == 'Y') { continue; }
      if (filt[0][0] != '1')
      { fprintf(stderr, "Format error 11: %s (%s)", line[0], id1); exit(-19); }
      if (filt[2][0] != '2')
      { fprintf(stderr, "Format error 12: %s (%s)", line[0], id1); exit(-20); }
    }

    if (line[0][0] != '@')
    { fprintf(stderr, "Format error 13: %s (%s)", line[0], id1); exit(-21); }
    if (line[4][0] != '@')
    { fprintf(stderr, "Format error 14: %s (%s)", line[4], id2); exit(-22); }
    if (line[2][0] != '+')
    { fprintf(stderr, "Format error 15: %s (%s)", line[2], id1); exit(-23); }
    if (line[6][0] != '+')
    { fprintf(stderr, "Format error 16: %s (%s)", line[6], id2); exit(-24); }

    if (flag[5] == 0)	/* length check */
    {
      if (length != (int)strlen(line[1]))
      { fprintf(stderr, "Format error 17: %s (%s)", line[1], id1); exit(-25); }
      if (length != (int)strlen(line[3]))
      { fprintf(stderr, "Format error 18: %s (%s)", line[3], id1); exit(-26); }
      if (length != (int)strlen(line[5]))
      { fprintf(stderr, "Format error 19: %s (%s)", line[5], id2); exit(-27); }
      if (length != (int)strlen(line[7]))
      { fprintf(stderr, "Format error 20: %s (%s)", line[7], id2); exit(-28); }
    }

    fputs(line[0], fastqc); fputs(line[1], fastqc);	/* output R1 */
    fputs(line[2], fastqc); fputs(line[3], fastqc);
    fputs(line[4], fastqd); fputs(line[5], fastqd);	/* output R2 */
    fputs(line[6], fastqd); fputs(line[7], fastqd);
  }
  if (fgets(line[4], MAX_CHAR, fastqb) != NULL)
  { fprintf(stderr, "Format error 21: %s", line[4]); exit(-29); }

  fclose(fastqa); fclose(fastqb); fclose(fastqc); fclose(fastqd);
  return EXIT_SUCCESS;
}
